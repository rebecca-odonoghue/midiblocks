#include "mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui_(new Ui::MainWindow)
{
    // Set up the UI from mainwindow.ui
    ui_->setupUi(this);

    // Initialise variables
    isMuted_ = true;
    inputType_ = NO_INPUT;
    outputType_ = NO_OUTPUT;
    inputArg_ = "";
    currentScaleIndex_ = 0;

    // Create the Input Processor and connect it's signals to slots
    // in MainWindow
    inputProcessor_ = new InputProcessor(this);
    connect(inputProcessor_, &InputProcessor::illegalWrite, this,
            &MainWindow::catchIllegalWrite);
    connect(inputProcessor_, &InputProcessor::fileFinished, this,
            &MainWindow::stop);
    connect(inputProcessor_, &InputProcessor::inputChanged, this,
            &MainWindow::inputChanged);

    // Creates an undo stack to allow undoing and redoing of commands
    undoStack_ = new QUndoStack(this);
    connect(undoStack_, &QUndoStack::cleanChanged, this,
            &MainWindow::enableSave);

    // Creates an undoAction to undo commands and be displayed on the GUI
    actionUndo_ = undoStack_->createUndoAction(this, tr("&Undo"));
    actionUndo_->setShortcut(QKeySequence::Undo);
    QIcon undoIcon;
    undoIcon.addFile(QStringLiteral(":/icons/Undo-26.png"), QSize(),
                     QIcon::Normal, QIcon::Off);
    actionUndo_->setIcon(undoIcon);
    ui_->mainToolBar->insertAction(ui_->actionImportScales, actionUndo_);

    // Creates a redoAction to redo commands and be displayed on the GUI
    actionRedo_ = undoStack_->createRedoAction(this, tr("&Redo"));
    actionRedo_->setShortcut(QKeySequence::Redo);
    QIcon redoIcon;
    redoIcon.addFile(QStringLiteral(":/icons/Redo-26.png"), QSize(),
                     QIcon::Normal, QIcon::Off);
    actionRedo_->setIcon(redoIcon);
    ui_->mainToolBar->insertAction(ui_->actionImportScales, actionRedo_);
    ui_->mainToolBar->insertSeparator(ui_->actionImportScales);

    // Generate the other toolbar content
    generateMainToolbar();
    loadScales("scales.csv");
    addMetronome();
    generateIoToolbar();
    generateBlockToolbar();

    // Set the initial scale in the processing thread
    inputProcessor_->setScale(&scales_.at(currentScale()));


    connect(ui_->actionImportScales, &QAction::triggered, this,
            &MainWindow::importScales);

    // Initialise the virtual piano and set it's initial scale
    keyboard_ = new Keyboard(this, &scales_.at(currentScale()));

    // Get the initial configuration information from the keyboard
    inputProcessor_->setConfigInfo(keyboard_->getConfigNotes());

    // Connect the InputProcessor to receive all future configuration
    // information
    connect(keyboard_, &Keyboard::sendConfigInfo, inputProcessor_,
            &InputProcessor::setConfigInfo);

    // Initially deactivate virtual piano, grab the keyboard for hotkeys
    keyboard_->deactivate();
    keyboard_->grabKeyboard();
    ui_->keyboardPanel->addWidget(keyboard_);

    // Call changeScale() whenever a scale selection has changed
    connect(scaleRootSelect_, SIGNAL(currentIndexChanged(int)),
            this, SLOT(changeScale()));
    connect(scaleModeSelect_, SIGNAL(currentIndexChanged(int)),
            this, SLOT(changeScale()));

    // Create the container to display the blocks
    blockFrame_ = new BlockFrame(this);
    ui_->blockScrollArea->setWidget(blockFrame_);

    // Connect the actions generated by mainwindow.ui to relevant methods
    connect(ui_->actionDelete, &QAction::triggered,
            this, &MainWindow::deleteBlock);
    connect(ui_->actionShiftBlockLeft, &QAction::triggered,
            this, &MainWindow::shiftBlockLeft);
    connect(ui_->actionShiftBlockRight, &QAction::triggered,
            this, &MainWindow::shiftBlockRight);
    connect(blockFrame_, &BlockFrame::blockSelected,
            this, &MainWindow::blockSelected);
    connect(blockFrame_, &BlockFrame::blockDeselected,
            this, &MainWindow::blockDeselected);
}

MainWindow::~MainWindow()
{
    delete ui_;
}

// Determine the corresponding Scale to the selections made in the two scale
// combo boxes
int MainWindow::currentScale() {
    QString root = scaleRootSelect_->currentText();
    QString mode = scaleModeSelect_->currentText();

    foreach(Scale scale, scales_) {
        if(noteLetters.at((int)scale.getRoot()) == root
                && scale.getMode() == mode) {
            return scales_.indexOf(scale);
        }
    }
    return -1;
}

// Changes the scale in the inputProcessor and virtual piano if the scale
// selected is valid, if it is not valid change the selection back to the
// previous index and notify the user
void MainWindow::changeScale() {
    if(currentScale() != -1) {
        currentScaleIndex_ = currentScale();
        const Scale* scale = &scales_.at(currentScaleIndex_);
        keyboard_->setScale(scale);
        inputProcessor_->setScale(scale);
    } else {
        PlaySound(TEXT("C:/WINDOWS/Media/Windows Error.wav"), NULL, SND_ASYNC);
        ui_->statusBar->showMessage("Scale not found.", 2000);
        Scale scale = scales_.at(currentScaleIndex_);
        scaleRootSelect_->setCurrentText(noteLetters.at((int)scale.getRoot()));
        scaleModeSelect_->setCurrentText(scale.getMode());
    }
}

// Read the scales contained in a CSV file, notify the user if the file is
// formatted incorrectly
void MainWindow::loadScales(QString fileName) {
    QList<Scale> loadedScales;
    QFile scalesFile(fileName);
    bool badFile = false;

    if (scalesFile.open(QIODevice::ReadOnly)) {
        while (!scalesFile.atEnd()) {
            QString name = "";
            QList<Note> notes = {};
            QByteArray line = scalesFile.readLine();
            if(line.endsWith("\r\n")) {
                line.chop(2);
            } else if (line.endsWith("\n")) {
                line.chop(1);
            }
            QList<QByteArray> cells = line.split(',');
            name = cells[0];
            for (int i = 1; i < cells.size(); i++) {
                if(noteLetters.contains(cells[i])) {
                    Note note = (Note)noteLetters.indexOf(cells[i]);
                    notes.append(note);
                } else if (!cells[i].isEmpty()){
                    badFile = true;
                }
            }

            if (notes.first() != notes.last()) {
                badFile = true;
            }

            Scale* scale = new Scale(name, notes);
            if(!loadedScales.contains(*scale))
                loadedScales.append(*scale);
        }

        scalesFile.close();

        if(!badFile) {
            scales_.append(loadedScales);
        }

        foreach(Scale scale, scales_) {
            QString root = noteLetters.at((int)scale.getRoot());
            if (scaleRootSelect_->findText(root) == -1)
                scaleRootSelect_->addItem(root, Qt::DisplayRole);
            if (scaleModeSelect_->findText(scale.getMode()) == -1) {
                scaleModeSelect_->addItem(scale.getMode(), Qt::DisplayRole);
            }
        }

        if (badFile){
            PlaySound(TEXT("C:/WINDOWS/Media/Windows Error.wav"),
                      NULL, SND_ASYNC);
            ui_->statusBar->showMessage("Scales file was incorrectly formatted "
                                       "and could not be loaded.", 2000);
        }
    }
}

// A method called when an input is sent but no output exists to notify
// the user
void MainWindow::catchIllegalWrite() {
    PlaySound(TEXT("C:/WINDOWS/Media/Windows Error.wav"), NULL, SND_ASYNC);
    ui_->statusBar->showMessage("No output device is selected.", 2000);
}

// Adds the metronome to the GUI
void MainWindow::addMetronome() {
    QWidget* spacer = new QWidget();
    spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    QIcon muteIcon;
    muteIcon.addFile(QStringLiteral(":/icons/Mute Filled-25.png"), QSize(),
                     QIcon::Normal, QIcon::Off);
    actionMute_ = new QAction(this);
    actionMute_->setIcon(muteIcon);
    connect(actionMute_, &QAction::triggered, this, &MainWindow::toggleMute);

    metronome_ = new Metronome(this);

    // Connect the metronome to the InputProcessor
    connect(inputProcessor_, SIGNAL(tempoChanged(int)),
            tempoSelect_, SLOT(setValue(int)));
    connect(tempoSelect_, SIGNAL(valueChanged(int)),
            metronome_, SLOT(setTempo(int)));
    connect(inputProcessor_, &InputProcessor::startMetronome,
            metronome_, &Metronome::start);
    connect(inputProcessor_, &InputProcessor::stopMetronome,
            metronome_, &Metronome::stop);
    connect(metronome_, &Metronome::onTick, inputProcessor_,
            &InputProcessor::onTick);

    ui_->mainToolBar->addWidget(spacer);
    ui_->mainToolBar->addSeparator();
    ui_->mainToolBar->addAction(actionMute_);
    ui_->mainToolBar->addSeparator();
    ui_->mainToolBar->addWidget(metronome_);
}

// Generate the main GUI toolbar
void MainWindow::generateMainToolbar() {
    QLabel* scaleLabel = new QLabel();
    scaleLabel->setText("Set Global Scale:");
    scaleLabel->setStyleSheet("QLabel { color: #4c4c4c; font: 10pt; "
                              "padding: 0px 7px 0px 20px;}");
    QLabel* tempoLabel = new QLabel();
    tempoLabel->setText("Set Tempo:");
    tempoLabel->setStyleSheet("QLabel { color: #4c4c4c; font: 10pt; "
                              "padding: 0px 7px 0px 20px;}");

    tempoSelect_ = new QSpinBox();
    tempoSelect_->setRange(20, 240);
    tempoSelect_->setValue(120);
    tempoSelect_->setSuffix(" BPM");
    scaleRootSelect_ = new QComboBox(this);
    scaleModeSelect_ = new QComboBox(this);

    scaleRootSelect_->setMinimumWidth(25);
    scaleModeSelect_->setMinimumWidth(150);

    QWidget* spacer = new QWidget();
    spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    spacer->setMaximumWidth(10);

    ui_->mainToolBar->insertWidget(ui_->actionImportScales, scaleLabel);
    ui_->mainToolBar->insertWidget(ui_->actionImportScales, scaleRootSelect_);
    ui_->mainToolBar->insertWidget(ui_->actionImportScales, spacer);
    ui_->mainToolBar->insertWidget(ui_->actionImportScales, scaleModeSelect_);
    ui_->mainToolBar->addWidget(tempoLabel);
    ui_->mainToolBar->addWidget(tempoSelect_);
}

// Generate the toolbar containing input and output options
void MainWindow::generateIoToolbar() {
    QLabel* input = new QLabel();
    input->setText("Input Device: ");
    input->setStyleSheet("QLabel { color: #4c4c4c; font: 10pt;}");
    QLabel* output = new QLabel();
    output->setText("Output Device: ");
    output->setStyleSheet("QLabel { color: #4c4c4c; font: 10pt; "
                          "padding: 0px 0px 0px 15px;}");
    outputLabel_ = new QLabel();
    outputLabel_->setStyleSheet("QLabel { color: black; font: 10pt;}");
    outputLabel_->setText("None");
    inputLabel_ = new QLabel();
    inputLabel_->setStyleSheet("QLabel { color: black; font: 10pt;}");
    inputLabel_->setText("None");

    QWidget* spacer = new QWidget(this);
    spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    ui_->ioToolBar->insertWidget(ui_->actionSelectInput, input);
    ui_->ioToolBar->insertWidget(ui_->actionSelectInput, inputLabel_);
    ui_->ioToolBar->insertSeparator(ui_->actionSelectOutput);
    ui_->ioToolBar->insertWidget(ui_->actionSelectOutput, output);
    ui_->ioToolBar->insertWidget(ui_->actionSelectOutput, outputLabel_);
    ui_->ioToolBar->insertSeparator(ui_->actionRecord);
    ui_->ioToolBar->insertWidget(ui_->actionRecord, spacer);
    ui_->ioToolBar->insertSeparator(ui_->actionRecord);

}

// Generate the toolbar containing block addition and editing
void MainWindow::generateBlockToolbar() {
    editBlockAction_ = new QAction(this);

    QLabel* addBlock = new QLabel();
    addBlock->setText("Add Processing Block: ");
    addBlock->setStyleSheet("QLabel { color: #4c4c4c; font: 10pt;}");

    addBlockSelect_ = new QComboBox();
    QStringList blockTypes = {"Select Block Type", "Pitch Shift",
                              "Arpeggiator", "Monophonic", "Chordify", "Gate"};
    addBlockSelect_->addItems(blockTypes);
    addBlockSelect_->setCurrentIndex(0);

    connect(addBlockSelect_, SIGNAL(currentIndexChanged(int)),
            this, SLOT(selectBlockType(int)));

    ui_->blockToolBar->insertWidget(ui_->actionAddBlock, addBlock);
    ui_->blockToolBar->insertWidget(ui_->actionAddBlock, addBlockSelect_);

    QLabel* editBlock = new QLabel();
    editBlock->setText("Edit Processing Block: ");
    editBlock->setStyleSheet("QLabel { color: #4c4c4c; font: 10pt; "
                             "padding: 0px 0px 0px 10px;}");
    ui_->blockToolBar->insertWidget(ui_->actionShiftBlockLeft, editBlock);

    QLabel* shiftLabel = new QLabel();
    shiftLabel->setText("Shift: ");
    shiftLabel->setMaximumSize(40, 20);
    shiftSelect_ = new QSpinBox();
    shiftSelect_->setRange(-83, 83);
    shiftSelect_->setSuffix(" notes");
    shiftSelect_->setValue(0);
    shiftSelect_->setMaximumSize(65, 20);

    QSplitter* shiftControl = new QSplitter();
    shiftControl->setStyleSheet("QSplitter { padding: 0px 10px;}");
    shiftControl->addWidget(shiftLabel);
    shiftControl->addWidget(shiftSelect_);
    editShiftAction_ = ui_->blockToolBar->addWidget(shiftControl);
    ui_->blockToolBar->removeAction(editShiftAction_);

    QLabel* patternLabel = new QLabel();
    patternLabel->setText("Pattern: ");
    patternLabel->setMaximumSize(45, 20);
    patternSelect_ = new QComboBox();
    patternSelect_->addItems(patternNames);
    patternSelect_->setMaximumSize(120, 20);

    QSplitter* patternControl = new QSplitter();
    patternControl->setStyleSheet("QSplitter { padding: 0px 10px;}");
    patternControl->addWidget(patternLabel);
    patternControl->addWidget(patternSelect_);
    editPatternAction_ = ui_->blockToolBar->addWidget(patternControl);
    ui_->blockToolBar->removeAction(editPatternAction_);

    QLabel* nptLabel = new QLabel();
    nptLabel->setText("Notes per tick: ");
    nptLabel->setMaximumSize(75, 20);
    QLabel* modeLabel = new QLabel();
    modeLabel->setText("Mode: ");
    modeLabel->setMaximumSize(30, 20);

    nptSelect_ = new QDoubleSpinBox();
    nptSelect_->setRange(0.01, 25.0);
    nptSelect_->setSingleStep(0.01);
    nptSelect_->setSuffix(" notes");
    nptSelect_->setValue(1.0);
    nptSelect_->setMaximumSize(80, 20);

    modeSelect_ = new QComboBox();
    modeSelect_->addItems(modeNames);
    modeSelect_->setMaximumSize(75, 20);

    QSplitter* gateControl = new QSplitter();
    gateControl->setStyleSheet("QSplitter { padding: 0px 10px;}");
    gateControl->addWidget(nptLabel);
    gateControl->addWidget(nptSelect_);
    gateControl->addWidget(modeLabel);
    gateControl->addWidget(modeSelect_);
    editGateAction_ = ui_->blockToolBar->addWidget(gateControl);
    ui_->blockToolBar->removeAction(editGateAction_);
}

// Called when a block type has been selected to add
void MainWindow::selectBlockType(int index) {
    blockFrame_->deselectBlocks();
    if (index == 0) {
        hideBlockParameters();
        ui_->actionAddBlock->setEnabled(false);
    } else {
        showBlockParameters(false, (BlockType)(index - 1));
        ui_->actionAddBlock->setEnabled(true);
    }
}

// Called when a block has been selected to allow editing
void MainWindow::showBlockParameters(bool blockExists, BlockType type) {
    ui_->blockToolBar->removeAction(editBlockAction_);
    ui_->blockToolBar->removeAction(ui_->actionApplyChanges);

    switch(type) {
        case PITCH_SHIFT:
            editBlockAction_ = editShiftAction_;
            break;
        case ARPEGGIATOR:
            editBlockAction_ = editPatternAction_;
            break;
        case GATE:
            editBlockAction_ = editGateAction_;
            break;
        default:
            return;
    }

    if(blockExists) {
        ui_->blockToolBar->addAction(editBlockAction_);
        ui_->blockToolBar->addAction(ui_->actionApplyChanges);
    } else {
        shiftSelect_->setValue(0);
        patternSelect_->setCurrentIndex(0);
        nptSelect_->setValue(1.0);
        modeSelect_->setCurrentIndex(0);
        ui_->blockToolBar->insertAction(ui_->actionAddBlock, editBlockAction_);
    }
}

// Called when a block is deselected to hide the edit controls
void MainWindow::hideBlockParameters() {
    ui_->blockToolBar->removeAction(editBlockAction_);
    ui_->blockToolBar->removeAction(ui_->actionApplyChanges);
}

// Called when a block is selected to show the edit controls
void MainWindow::blockSelected(int index, BlockType type) {
    selectedBlockIndex_ = index;
    Block* selectedBlock = inputProcessor_->getBlock(index);

    addBlockSelect_->setCurrentIndex(0);

    checkShiftButtons();
    ui_->actionDelete->setEnabled(true);

    switch(type) {
        case PITCH_SHIFT:
            shiftSelect_->setValue(((PitchShift*)selectedBlock)->getShift());
            break;
        case ARPEGGIATOR:
            patternSelect_->setCurrentIndex((int)(
                            ((Arpeggiator*)selectedBlock)->getPattern()));
            break;
        case GATE:
            nptSelect_->setValue(((Gate*)selectedBlock)->getNotesPerTick());
            modeSelect_->setCurrentIndex(
                        (int)(((Gate*)selectedBlock)->getMode()));
            break;
        case MONOPHONIC:
        case CHORDIFY:
            return;
    }

    showBlockParameters(true, type);
}

// Called when a block is deselected to hide the edit controls
void MainWindow::blockDeselected() {
    ui_->actionShiftBlockLeft->setEnabled(false);
    ui_->actionShiftBlockRight->setEnabled(false);
    ui_->actionDelete->setEnabled(false);

    hideBlockParameters();
}

// Adds a block to the GUI and processing chain
void MainWindow::addBlock() {
    BlockType type = (BlockType)(addBlockSelect_->currentIndex() - 1);
    QStringList blockArgs;
    switch(type) {
        case PITCH_SHIFT:
            blockArgs.append(shiftSelect_->cleanText());
            break;
        case ARPEGGIATOR:
            blockArgs.append(patternSelect_->currentText());
            break;
        case GATE:
            blockArgs.append(nptSelect_->cleanText());
            blockArgs.append(modeSelect_->currentText());
            break;
        default:
            break;
    }

    addBlockSelect_->setCurrentIndex(0);
    QUndoCommand* addCommand = new AddBlockCommand(type, blockArgs,
                                                   blockFrame_,
                                                   inputProcessor_);
    undoStack_->push(addCommand);
}

// Deletes a block from the GUI and processing chain
void MainWindow::deleteBlock() {
    QUndoCommand* deleteCommand = new DeleteBlockCommand(selectedBlockIndex_,
                                                         blockFrame_,
                                                         inputProcessor_);
    undoStack_->push(deleteCommand);
}

void MainWindow::shiftBlockLeft() {
    QUndoCommand* shiftCommand = new ShiftBlockCommand(selectedBlockIndex_,
                                                       true,
                                                       blockFrame_,
                                                       inputProcessor_);
    undoStack_->push(shiftCommand);
    selectedBlockIndex_--;
    checkShiftButtons();
}

void MainWindow::shiftBlockRight() {
    QUndoCommand* shiftCommand = new ShiftBlockCommand(selectedBlockIndex_,
                                                       false,
                                                       blockFrame_,
                                                       inputProcessor_);
    undoStack_->push(shiftCommand);
    selectedBlockIndex_++;
    checkShiftButtons();
}

// Checks if the selected block, if any, is in a position to shift left
// or right
void MainWindow::checkShiftButtons() {
    if (selectedBlockIndex_ > 0)
        ui_->actionShiftBlockLeft->setEnabled(true);
    else
        ui_->actionShiftBlockLeft->setEnabled(false);
    if (selectedBlockIndex_ < inputProcessor_->numBlocks() - 1)
        ui_->actionShiftBlockRight->setEnabled(true);
    else
        ui_->actionShiftBlockRight->setEnabled(false);
}

// Applies any changes made to the selected block
void MainWindow::applyChanges() {
    QStringList params;

    switch(blockFrame_->getBlock(selectedBlockIndex_)->getBlockType()) {
        case PITCH_SHIFT:
            params.append(shiftSelect_->cleanText());
            params.append(shiftSelect_->text());
            break;
        case ARPEGGIATOR:
            params.append(QString::number(patternSelect_->currentIndex()));
            params.append(patternSelect_->currentText());
            break;
        case GATE:
            params.append(nptSelect_->cleanText());
            params.append(QString::number(modeSelect_->currentIndex()));
            params.append(nptSelect_->text());
            params.append(modeSelect_->currentText());
            break;
        case MONOPHONIC:
        case CHORDIFY:
            return;
    }

    QUndoCommand* applyChangesCommand = new ApplyChangesCommand(
            selectedBlockIndex_, params, blockFrame_, inputProcessor_);
    undoStack_->push(applyChangesCommand);
}

// Overrides the keyPresssEvent and keyReleaseEvent to capture
//keys played on the paino
void MainWindow::keyPressEvent(QKeyEvent *ev) {
    if(!ev->isAutoRepeat()) {
        foreach(PianoKey* key, keyboard_->getDisplayedKeys()) {
            if(ev->key() == key->getShortcut()) {
                key->keyOn();
            }
        }
    }
    QMainWindow::keyPressEvent(ev);
}

void MainWindow::keyReleaseEvent(QKeyEvent *ev) {
    if(!ev->isAutoRepeat()) {
        foreach(PianoKey* key, keyboard_->getDisplayedKeys()) {
            if(ev->key() == key->getShortcut()) {
                key->keyOff();
            }
        }
    }
    QMainWindow::keyPressEvent(ev);
}

// Chooses the scale file to load
void MainWindow::importScales() {
    QFileDialog dialog(this);
    QString homeDir = QStandardPaths::writableLocation(
                QStandardPaths::DocumentsLocation);
    QString fileName = dialog.getOpenFileName(this, tr("Import Scales File"),
                                              homeDir, tr("CSV files (*.csv)"));
    loadScales(fileName);
}

// Checks for a clean state and whether a configuration can be saved
void MainWindow::enableSave(bool clean) {
    if(clean) {
        ui_->actionSaveProject->setEnabled(false);
    } else {
        ui_->actionSaveProject->setEnabled(true);
    }
}

// Selects a configuration to be loaded
void MainWindow::loadProj() {
    if(!undoStack_->isClean()) {
        int action = loseChanges();
        if (action == 0) {
            return;
        } else if (action == 1) {
            saveProj();
        }
    }

    QFileDialog dialog(this);
    QString homeDir = QStandardPaths::writableLocation(
                QStandardPaths::DocumentsLocation);
    QString fileName = dialog.getOpenFileName(this, tr("Load MIDIBlocks Project"),
                            homeDir, tr("MIDIBlocks Project Files (*.MBProj)"));
    if (!fileName.isNull()) {
        cleanProject();
        saveFileName_ = fileName;
        readProjectFile(saveFileName_);
        undoStack_->clear();
    }
}

// If the project has been previously saved, saves the project, otherwise
// prompts for save file selection
void MainWindow::saveProj() {
    if(saveFileName_ == "") {
        this->saveProjAs();
    } else {
        writeProjectFile(saveFileName_);
    }
}

// Prompts for save file selection
void MainWindow::saveProjAs() {
    QFileDialog dialog(this);
    QString homeDir = QStandardPaths::writableLocation(
                QStandardPaths::DocumentsLocation);
    QString fileName = dialog.getSaveFileName(this,
                                    tr("Save MIDIBlocks Project"),
                                    homeDir + "/MIDI Blocks Project.MBProj",
                                    tr("MIDIBlocks Project Files (*.MBProj)"));

    if (!fileName.isNull()) {
        saveFileName_ = fileName;
        writeProjectFile(saveFileName_);
    }
}

// Writes the configuration file
void MainWindow::writeProjectFile(QString fileName) {
    InputData input;
    QList<BlockData> blocks;
    BlockData blockData;
    BlockWidget* block;

    input.type = (int)inputType_;
    input.arg = inputArg_;

    for(int i = 0; i < blockFrame_->blockCount(); i++) {
        block = blockFrame_->getBlock(i);
        blockData.type = (int)block->getBlockType();
        blockData.firstParameter = block->getParameter(1);
        blockData.secondParameter = block->getParameter(2);
        blocks << blockData;
    }

    QFile saveFile(fileName);
    saveFile.open(QIODevice::WriteOnly);
    QDataStream stream(&saveFile);
    stream.setVersion(QDataStream::Qt_5_5);

    stream << input;
    stream << blocks;

    undoStack_->setClean();
    saveFile.flush();
    saveFile.close();
}

// Reads a configuration file
void MainWindow::readProjectFile(QString fileName) {
    InputData input;
    QList<BlockData> blocks;

    QFile loadFile(fileName);
    loadFile.open(QIODevice::ReadOnly);
    QDataStream stream(&loadFile);
    stream.setVersion(QDataStream::Qt_5_5);

    stream >> input;
    stream >> blocks;
    loadFile.close();

    changeInput((InputType)input.type, input.arg);

    foreach(BlockData block, blocks) {
        blockFrame_->addBlock((BlockType)block.type,
                {block.firstParameter, block.secondParameter});
        inputProcessor_->addBlock((BlockType)block.type,
                {block.firstParameter, block.secondParameter});
    }
}

// Overrides the default close event to prompt if any unsaved changes exist
void MainWindow::closeEvent(QCloseEvent *event) {
    if(undoStack_->isClean()) {
        cleanProject();
        event->accept();
    } else {
        int action = loseChanges();
        if(action == 0) {
            event->ignore();
        } else if (action == 1) {
            saveProj();
            cleanProject();
            event->accept();
        } else {
            cleanProject();
            event->accept();
        }
    }
}

// Checks for a clean project, and asks the user to lose changes if it is not
void MainWindow::newProj() {
    if (undoStack_->isClean()) {
        cleanProject();
    } else {
        int action = loseChanges();
        if (action == 0) {
            return;
        } else if (action == 1) {
            saveProj();
            cleanProject();
        } else {
            cleanProject();
        }
    }
}

// Cleans the project();
void MainWindow::cleanProject() {
    stop();
    changeInput(NO_INPUT, "");
    saveFileName_ = "";
    undoStack_->clear();
    inputProcessor_->newProject();
    blockFrame_->clearBlocks();
}

// Executes the lose changes dialog
int MainWindow::loseChanges() {
    PlaySound(TEXT("C:/WINDOWS/Media/Windows Error.wav"), NULL, SND_ASYNC);
    LoseChanges* confirmWindow = new LoseChanges(this);
    confirmWindow->setWindowTitle("Lose Changes");
    confirmWindow->exec();
    return confirmWindow->result();
}

// Executes the select Output dialog
void MainWindow::selectOutput() {
    ui_->actionPlay->setEnabled(false);
    ui_->actionRecord->setEnabled(false);
    ui_->actionStop->setEnabled(false);
    QStringList comPortNames = inputProcessor_->getOutputComPortNames();
    QStringList midiPortNames = inputProcessor_->getOutputMidiPortNames();
    SelectOutput* selectOutputDialog = new SelectOutput(this, comPortNames,
                                                        midiPortNames);
    selectOutputDialog->setWindowTitle("Select Output Device");
    connect(selectOutputDialog, &SelectOutput::outputSelected, inputProcessor_,
            &InputProcessor::changeOutput);
    connect(selectOutputDialog, &SelectOutput::outputSelected, this,
            &MainWindow::changeOutput);
    selectOutputDialog->setModal(true);
    selectOutputDialog->exec();
}

// Executes the select input dialog
void MainWindow::selectInput() {
    ui_->actionPlay->setEnabled(false);
    ui_->actionRecord->setEnabled(false);
    ui_->actionStop->setEnabled(false);
    QStringList portNames = inputProcessor_->getInputPortNames();
    SelectInput* selectInputDialog = new SelectInput(this, portNames);
    selectInputDialog->setWindowTitle("Select Input Device");
    connect(selectInputDialog, &SelectInput::inputSelected, this,
            &MainWindow::changeInput);
    selectInputDialog->exec();
}

// Called on input change to modify GUI
void MainWindow::inputChanged(InputType inputType) {
    inputType_ = inputType;
    inputLabel_->setText(inputStrings.at(inputType));
    if (inputType == PIANO) {
        keyboard_->addPianoInput((PianoInput*)(inputProcessor_->getInput()));
        keyboard_->activate();
    } else {
        keyboard_->deactivate();
    }
    activateButtons();
}

// Executes and stores a change of input
void MainWindow::changeInput(InputType inputType, QString arg) {
    QUndoCommand* changeInputCommand = new ChangeInputCommand(inputType_,
                                                              inputType,
                                                              arg,
                                                              inputProcessor_);
    undoStack_->push(changeInputCommand);
    inputArg_ = arg;
}

// Called on output change to modify gui
void MainWindow::changeOutput(OutputType outputType) {
    outputType_ = outputType;
    outputLabel_->setText(outputStrings.at(outputType_));
    if(outputType_ == USB || outputType_ == MIDI_DRIVER_OUT) {
        inputProcessor_->startOutput();
    }
    activateButtons();
}

// Shows the about dialog
void MainWindow::about() {
    QWidget* aboutWindow = new QWidget();
    Ui::About ui;
    ui.setupUi(aboutWindow);
    aboutWindow->setWindowTitle("About MIDIBlocks");
    aboutWindow->show();
}

// Checks for the appropriate activation state of the play, stop and
// record buttons
void MainWindow::activateButtons() {
    if(inputType_ == MIDI_FILE_IN) {
        ui_->actionRecord->setEnabled(false);
        ui_->actionPlay->setEnabled(true);
    } else if (outputType_ == MIDI_FILE_OUT) {
        ui_->actionRecord->setEnabled(true);
        ui_->actionPlay->setEnabled(false);
    } else {
        ui_->actionRecord->setEnabled(false);
        ui_->actionPlay->setEnabled(false);
    }
    ui_->actionStop->setEnabled(false);
}

// Plays the input file
void MainWindow::play() {
    if (outputType_ != NO_OUTPUT) {
        inputProcessor_->startInput();
        if(outputType_ == MIDI_FILE_OUT) {
            inputProcessor_->startOutput();
        }
        ui_->actionPlay->setEnabled(false);
        ui_->actionStop->setEnabled(true);
    } else {
        catchIllegalWrite();
    }
}

// Stops playing or recording
void MainWindow::stop() {
    if(outputType_ == MIDI_FILE_OUT) {
        inputProcessor_->stopOutput();
    }
    if(inputType_ == MIDI_FILE_IN) {
        inputProcessor_->stopInput();
    }
    activateButtons();
}

// Records to the output file
void MainWindow::record() {
    inputProcessor_->startOutput();
    ui_->actionRecord->setEnabled(false);
    ui_->actionStop->setEnabled(true);
}

// Mutes and unmutes the metronome
void MainWindow::toggleMute() {
    if(isMuted_) {
        actionMute_->setIcon(QIcon(":/icons/Medium Volume Filled-25.png"));
        metronome_->setMuted(false);
        isMuted_ = false;
    } else {
        actionMute_->setIcon(QIcon(":/icons/Mute Filled-25.png"));
        metronome_->setMuted(true);
        isMuted_ = true;
    }
}
